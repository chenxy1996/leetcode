package dp._887_经典_困难_鸡蛋掉落.最好的方法;

/**
 * 题目转变为 K 个鸡蛋，T 次投掷机会所能测得的最大楼层 F
 * 1 个鸡蛋，T 次机会只能一次一次的
 * 上面的方法的思路，都还是顺着题目的思路的进行的，其实我们可以换一个思路来想：
 * “求k个鸡蛋在m步内可以测出多少层”。我们令dp[k][m]表示k个鸡蛋在m步内可以测出的最多的层数，
 * 那么当我们在第X层扔鸡蛋的时候，就有两种情况：
 *
 * 鸡蛋碎了，我们少了一颗鸡蛋，也用掉了一步，此时测出 N - X + dp[k-1][m-1]层，
 * X 和它上面的 N-X 层已经通过这次扔鸡蛋确定大于 F ；鸡蛋没碎，鸡蛋的数量没有变，
 * 但是用掉了一步，剩余 X + dp[k][m-1] ，X 层及其以下已经通过这次扔鸡蛋确定不会大于 F ；
 * 也就是说，我们每一次扔鸡蛋，不仅仅确定了下一次扔鸡蛋的楼层的方向，
 * 也确定了另一半楼层与F的大小关系，所以在下面的关键代码中，使用的不再是 max ，
 * 而是加法（这里是重点）。评论里有人问到为什么是相加，其实这里有一个惯性思维的误区，
 * 上面的诸多解法中，往往求 max 的思路是“两种方式中较大的那一个结果”，其实这里的相加，
 * 不是鸡蛋碎了和没碎两种情况的相加，
 * 而是“本次扔之后可能测出来的层数 + 本次扔之前已经测出来的层数”。
 *
 *
 * 解释一下最后一种解法中的递推公式是怎么来的。
 *
 * dp[k][m] 表示用 k 个鸡蛋移动 m 步可以“保证求解”的最大楼层数。
 *
 * 我们先解释一下定义中的几个概念：
 *
 * 所谓“求解”，意思就是给定楼层 N，我们能否找到临界楼层 F(F <= N)，使得鸡蛋
 * 从 F 层掉落刚好不会被摔碎。所谓“保证求解”，意思就是即使每次丢鸡蛋的结果都很差，最终仍能求解。
 *
 * 比如，给定 1 个鸡蛋移动 1 步，那么可以求解的最大楼层数为 1，即从 1 楼丢下，
 * 如果鸡蛋碎了，求得 F=0，如果鸡蛋没碎，求得 F=1。在这种情况下，假如我们给出一个 2 层的楼，
 * 就无法保证求解了，因为无论从哪一层丢出鸡蛋，都没有十足的把握能够一次求得 F，换句话说，
 * 虽然我们仍有一定的机会能够求解，但无法“保证求解”。
 *
 * 下面回到正题：
 *
 * 假设我们有 k 个鸡蛋可以移动 m 步，考虑某一步 t 应该在哪一层丢鸡蛋？一个正确的选择
 * 是在 dp[k-1][t-1] + 1 层丢鸡蛋，结果分两种情况：
 *
 * 如果鸡蛋碎了，我们首先排除了该层以上的所有楼层（不管这个楼有多高），
 * 而对于剩下的 dp[k-1][t-1] 层楼，我们一定能用 k-1 个鸡蛋在 t-1 步内求解。
 * 因此这种情况下，我们总共可以求解无限高的楼层。可见，这是一种非常好的情况，但并不总是发生。
 *
 * 如果鸡蛋没碎，我们首先排除了该层以下的 dp[k-1][t-1] 层楼，
 * 此时我们还有 k 个蛋和 t-1 步，那么我们去该层以上的楼层继续测得 dp[k][t-1] 层楼。
 * 因此这种情况下，我们总共可以求解 dp[k-1][t-1] + dp[k][t-1] + 1 层楼。
 *
 * 容易想象，在所有 m 步中只要有一次出现了第一种情况，那么我们就可以求解无限高的楼层。
 * 但“保证求解”的定义要求我们排除一切运气成分，因此我们只得认为每次移动都遇到第二种情况。于
 * 是得到递推公式：
 *
 * dp[k][t] = dp[k-1][t-1] + dp[k][t-1] + 1
 *
 * 基本的问题已经解决了，但是我们还遗留了一个问题：为什么要选择在 dp[k-1][t-1] + 1 层丢鸡蛋？
 *
 * 现在我们已经知道，如果我们每一步都在 dp[k-1][t-1] + 1 层丢鸡蛋，最终是一定能够求解的。
 * 但如果我们选择在更低的层或者更高的层丢鸡蛋会怎样呢？我们分两种情况讨论：
 *
 * 在更低的楼层丢鸡蛋。同样能够“保证求解”，但最终得到的并不是“最大”楼层数，我们没有充分
 * 挖掘鸡蛋数和移动次数的潜力，最终求解时会剩余一定量的鸡蛋或移动次数。
 *
 * 在更高的楼层丢鸡蛋。不妨假设高了一层，即在第 dp[k-1][t-1] + 2 层丢鸡蛋。如果鸡蛋碎掉了，
 * 我们仍然可以排除该层以上的所有楼层（不管这个楼有多高），但接下来就不好办了，因为我们剩下
 * 的 k-1 个鸡蛋在 t-1 步内只能“保证求解” dp[k-1][t-1] 的楼层，而现在剩余的楼层
 * 却是 dp[k-1][t-1] + 1，多了一层，因此无法“保证求解”！w
 *
 * 综上，我们用排除法证明了每一步都应该在第 dp[k-1][t-1] + 1 层丢鸡蛋。
 */
public class Solution {
    public static int superEggDrop(int K, int N) {
        int[][] dp = new int[N + 1][K + 1];
        int i = 1;
        outer:
        for(; i <= N; i++) {
            for(int j = 1; j <= K; j++) {
                dp[i][j] = dp[i - 1][j - 1] + 1 + dp[i - 1][j];
                if (dp[i][j] >= N) {
                    break outer;
                }
            }
        }
        return i;
    }

    public static void main(String[] args) {
        superEggDrop(2, 100);
//        System.out.println();
    }
}
